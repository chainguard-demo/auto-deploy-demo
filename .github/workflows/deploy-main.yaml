name: deploy-main

on:
  pull_request:
    types: [closed]

env:
  AWS_REGION: us-west-2
  EKS_CLUSTER_NAME: fpd2-eks

  ECR_REPO: python-openssl

  NAMESPACE: demo
  APP_NAME: python-demo

permissions: {}

jobs:
  push-image:
    if: >
      github.event.pull_request.merged == true &&
      github.event.pull_request.head.ref == 'apply-cve-fix'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      image: ${{ steps.out.outputs.image }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Go environment
        uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed
        with:
          cache: false

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.FPD_AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Install crane
        run: |
          set -euo pipefail
          go install github.com/google/go-containerregistry/cmd/crane@latest
          echo "$HOME/go/bin" >> "$GITHUB_PATH"
          crane version

      - name: Install Cosign
        uses: sigstore/cosign-installer@dc72c7d5c4d10cd6bcb8cf6e3fd625a9e5e537da

      - name: Install Grype (pinned release)
        run: |
          set -euo pipefail
          GRYPE_VERSION="v0.91.2"
          curl -sSfL "https://github.com/anchore/grype/releases/download/${GRYPE_VERSION}/grype_${GRYPE_VERSION#v}_linux_amd64.tar.gz" \
            | tar -xz -C /usr/local/bin grype
          grype version

      - uses: chainguard-dev/setup-chainctl@8d93dcbef466d3cf3533f67084f52eb74ef9d262
        with:
          identity: "4cf15780a13a9b6576d8b357e6524554c8c12a18/a662f56b58103354"

      - name: Auth to Chainguard registry (cgr.dev)
        run: |
          set -euo pipefail
          chainctl auth configure-docker

      - name: Read source image from merged PR content
        id: src
        run: |
          set -euo pipefail
          SRC="$(cat demo-results/new-image.txt)"
          echo "src=$SRC" >> "$GITHUB_OUTPUT"
          echo "Using source image: $SRC"

      - name: Copy image to ECR (and output digest-pinned ref)
        id: out
        run: |
          set -euo pipefail
          ECR="${{ steps.login-ecr.outputs.registry }}"
          TAG="${{ github.sha }}"
          DST_REPO="${ECR}/${{ env.ECR_REPO }}"
          DST="${DST_REPO}:${TAG}"

          echo "Copying:"
          echo "  SRC=${{ steps.src.outputs.src }}"
          echo "  DST=$DST"

          crane copy "${{ steps.src.outputs.src }}" "$DST"

          DIGEST="$(crane digest "$DST")"
          DST_REF="${DST_REPO}@${DIGEST}"

          echo "image=$DST_REF" >> "$GITHUB_OUTPUT"
          echo "Copied to: $DST_REF"

      - name: Keyless sign ECR image (GitHub OIDC)
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          cosign sign --yes "${{ steps.out.outputs.image }}"

      - name: Keyless attest Grype vulnerability predicate to ECR image
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          IMG="${{ steps.out.outputs.image }}"

          grype "$IMG" -o json > grype-new.json

          jq '{
            vulnerabilities: (
              [ .matches[]
                | {
                    id: .vulnerability.id,
                    severity: .vulnerability.severity,
                    package: .artifact.name,
                    installed: (.artifact.version // "")
                  }
              ] | unique
            )
          }' grype-new.json > vuln-predicate.json

          cosign attest \
            --yes \
            --type "https://in-toto.io/Statement/v1" \
            --predicate vuln-predicate.json \
            "$IMG"

  deploy:
    needs: [push-image]
    if: needs.push-image.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.FPD_AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.33.0"

      - name: Update kubeconfig (EKS)
        run: |
          set -euo pipefail
          aws eks update-kubeconfig \
            --region "${{ env.AWS_REGION }}" \
            --name "${{ env.EKS_CLUSTER_NAME }}"
          kubectl cluster-info

      - name: Ensure namespace exists
        run: |
          kubectl get namespace "${{ env.NAMESPACE }}" \
            || kubectl create namespace "${{ env.NAMESPACE }}"

      - name: Apply manifest (deployment.yaml)
        run: |
          set -euo pipefail
          kubectl apply -n "${{ env.NAMESPACE }}" -f services/python-web/deployment.yaml

      - name: Patch deployment image (digest) + rollout
        run: |
          set -euo pipefail
          IMAGE="${{ needs.push-image.outputs.image }}"
          echo "Deploying image: $IMAGE"

          kubectl set image -n "${{ env.NAMESPACE }}" \
            deployment/"${{ env.APP_NAME }}" \
            "${{ env.APP_NAME }}"="$IMAGE"

          kubectl rollout status -n "${{ env.NAMESPACE }}" \
            deployment/"${{ env.APP_NAME }}" \
            --timeout=10m