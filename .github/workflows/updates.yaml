name: updates

on:
  schedule:
    - cron: "0 * * * *"
  workflow_dispatch:

env:
  # Core demo images (set these to the pair you want to demonstrate)
  DEMO_OLD_IMAGE: "cgr.dev/cgr-demo.com/python:3.12-202508222152"
  DEMO_NEW_IMAGE: "cgr.dev/cgr-demo.com/python:3.12.12"

  # Toggle scanners
  SCAN_WITH_GRYPE: "true"
  SCAN_WITH_PRISMA_CLOUD: "true"
  OBJC_DISABLE_INITIALIZE_FORK_SAFETY: "YES"

permissions: {}

jobs:
  check-for-fixes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: write
      id-token: write

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Setup Go environment
        uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed
        with:
          cache: false

      # Token used for PR creation etc. (your existing Octo STS setup)
      - uses: octo-sts/action@6177b4481c00308b3839969c3eca88c96a91775f
        id: octo-sts
        with:
          scope: chainguard-demo/auto-deploy-demo
          identity: updates

      - name: Install Crane
        run: go install github.com/google/go-containerregistry/cmd/crane@latest

      - name: Install Grype (pinned release)
        if: env.SCAN_WITH_GRYPE == 'true'
        run: |
          set -euo pipefail
          GRYPE_VERSION="v0.91.2"
          curl -sSfL "https://github.com/anchore/grype/releases/download/${GRYPE_VERSION}/grype_${GRYPE_VERSION#v}_linux_amd64.tar.gz" \
            | tar -xz -C /usr/local/bin grype
          grype version

      - name: Install Cosign
        uses: sigstore/cosign-installer@dc72c7d5c4d10cd6bcb8cf6e3fd625a9e5e537da

      - uses: chainguard-dev/setup-chainctl@8d93dcbef466d3cf3533f67084f52eb74ef9d262
        with:
          identity: "4cf15780a13a9b6576d8b357e6524554c8c12a18/a662f56b58103354"

      - name: Auth to Registry
        run: chainctl auth configure-docker

      - name: Current Image and New Image Provided by Chainguard SLA
        run: |
          echo "OLD_IMAGE=${{ env.DEMO_OLD_IMAGE }}" >> "$GITHUB_ENV"
          echo "NEW_IMAGE=${{ env.DEMO_NEW_IMAGE }}" >> "$GITHUB_ENV"
          echo "OLD_IMAGE=${{ env.DEMO_OLD_IMAGE }}"
          echo "NEW_IMAGE=${{ env.DEMO_NEW_IMAGE }}"

      - name: Cosign verify new image signature
        run: |
          set -euo pipefail
          CATALOG_SYNCER="4cf15780a13a9b6576d8b357e6524554c8c12a18/c03040118377d88c"
          APKO_BUILDER="4cf15780a13a9b6576d8b357e6524554c8c12a18/ca93125e202f81f8"
          cosign verify \
            --certificate-oidc-issuer=https://issuer.enforce.dev \
            --certificate-identity-regexp="https://issuer.enforce.dev/(${CATALOG_SYNCER}|${APKO_BUILDER})" \
            "${{ env.NEW_IMAGE }}" | jq

      - name: Run chainctl images diff + build PR summary
        id: diff_vulnerabilities
        run: |
          set -euo pipefail

          OLD_IMAGE="${{ env.OLD_IMAGE }}"
          NEW_IMAGE="${{ env.NEW_IMAGE }}"

          echo "FIX_CVE=false" >> "$GITHUB_ENV"

          echo "Running chainctl images diff..."
          set +e
          DIFF_OUTPUT="$(chainctl images diff "$OLD_IMAGE" "$NEW_IMAGE" --output json 2>&1)"
          RC=$?
          set -e

          echo "chainctl exit code: $RC"
          echo "$DIFF_OUTPUT"

          if [ $RC -ne 0 ]; then
            echo "chainctl images diff failed; skipping."
            exit 0
          fi

          # Extract JSON from mixed log+json output
          DIFF_JSON="$(echo "$DIFF_OUTPUT" | awk 'BEGIN{found=0} /^\{/{found=1} found{print}')"

          if ! echo "$DIFF_JSON" | jq -e . >/dev/null 2>&1; then
            echo "Diff output was not valid JSON; skipping."
            exit 0
          fi

          # Determine whether any vulnerabilities were removed
          REMOVED_COUNT="$(echo "$DIFF_JSON" | jq -r '(.vulnerabilities.removed // []) | length')"
          if [ "$REMOVED_COUNT" -gt 0 ]; then
            echo "FIX_CVE=true" >> "$GITHUB_ENV"
          else
            echo "No removed vulnerabilities; not opening PR."
            exit 0
          fi

          # Save diff json for later steps if you want
          echo "$DIFF_JSON" > diff.json

          # Build a readable Markdown summary for the PR
          {
            echo "## Image update"
            echo ""
            echo "**OLD_IMAGE:** \`$OLD_IMAGE\`"
            echo "**NEW_IMAGE:** \`$NEW_IMAGE\`"
            echo ""

            echo "## Packages changed"
            echo ""
            echo "| Package | Old | New |"
            echo "|---|---|---|"
            echo "$DIFF_JSON" | jq -r '
              (.packages.changed // [])
              | sort_by(.name)
              | .[]
              | "| \(.name) | \(.previous.version // "-") | \(.current.version // "-") |"
            ' || true
            echo ""

            echo "## Vulnerabilities removed"
            echo ""
            for sev in Critical High Medium Low Unknown; do
              COUNT="$(echo "$DIFF_JSON" | jq -r --arg s "$sev" '(.vulnerabilities.removed // []) | map(select(.severity == $s)) | length')"
              if [ "$COUNT" -gt 0 ]; then
                echo "### $sev ($COUNT)"
                echo ""
                echo "| ID | Package | Installed | Fixed in |"
                echo "|---|---|---|---|"
                echo "$DIFF_JSON" | jq -r --arg s "$sev" '
                  (.vulnerabilities.removed // [])
                  | map(select(.severity == $s))
                  | sort_by(.id)
                  | .[]
                  | "| \(.id) | \(.package.name // "-") | \(.package.installedVersion // "-") | \(.package.fixedVersion // "-") |"
                ' || true
                echo ""
              fi
            done

            # If severities are missing/unexpected, still show everything
            OTHER_COUNT="$(echo "$DIFF_JSON" | jq -r '
              (.vulnerabilities.removed // [])
              | map(select((.severity // "") | IN("Critical","High","Medium","Low","Unknown") | not))
              | length
            ')"
            if [ "$OTHER_COUNT" -gt 0 ]; then
              echo "### Other ($OTHER_COUNT)"
              echo ""
              echo "| ID | Severity | Package | Installed | Fixed in |"
              echo "|---|---|---|---|---|"
              echo "$DIFF_JSON" | jq -r '
                (.vulnerabilities.removed // [])
                | map(select((.severity // "") | IN("Critical","High","Medium","Low","Unknown") | not))
                | sort_by(.id)
                | .[]
                | "| \(.id) | \(.severity // "-") | \(.package.name // "-") | \(.package.installedVersion // "-") | \(.package.fixedVersion // "-") |"
              ' || true
              echo ""
            fi
          } > PR_BODY.md

          echo "Wrote PR_BODY.md:"
          sed -n '1,200p' PR_BODY.md

      - name: Rebuild PR body using Grype comparison (adds package/fix info)
        if: env.FIX_CVE == 'true'
        run: |
          set -euo pipefail

          OLD="${{ env.OLD_IMAGE }}"
          NEW="${{ env.NEW_IMAGE }}"

          # Scan both images in JSON mode
          grype "$OLD" -o json > grype-old.json
          grype "$NEW" -o json > grype-new.json

          # Normalize old scan into TSV: id, pkg, installed, fixed, severity
          jq -r '
            .matches[]
            | {
                id: .vulnerability.id,
                severity: .vulnerability.severity,
                pkg: .artifact.name,
                installed: (.artifact.version // ""),
                fixed: (
                  .vulnerability.fix.versions[0]
                  // .vulnerability.fix.version
                  // ""
                )
              }
            | "\(.id)\t\(.pkg)\t\(.installed)\t\(.fixed)\t\(.severity)"
          ' grype-old.json | sort -u > old.tsv

          # Normalize new scan into key set: id, pkg, installed
          jq -r '
            .matches[]
            | "\(.vulnerability.id)\t\(.artifact.name)\t\(.artifact.version)"
          ' grype-new.json | sort -u > new.keys

          # Removed = present in old but not in new
          awk -F'\t' 'NR==FNR {k[$0]=1; next} {key=$1"\t"$2"\t"$3; if (!k[key]) print $0}' new.keys old.tsv > removed.tsv || true

          {
            echo "# CVE Fix Summary"
            echo
            echo "**OLD_IMAGE:** \`$OLD\`"
            echo "**NEW_IMAGE:** \`$NEW\`"
            echo
            echo "## Removed Vulnerabilities"
            echo

            if [ ! -s removed.tsv ]; then
              echo "_No removed vulnerabilities detected._"
              echo
            else
              echo "| Vulnerability | Package | Installed | Fixed in | Severity |"
              echo "|---|---|---|---|---|"

              # Sort by severity priority
              awk -F'\t' '
              function sev_rank(s) {
                if (s=="Critical") return 1;
                if (s=="High")     return 2;
                if (s=="Medium")   return 3;
                if (s=="Low")      return 4;
                return 5;
              }
              {
                print sev_rank($5) "|" $0
              }
              ' removed.tsv \
              | sort -t'|' -k1,1n -k2,2 \
              | cut -d'|' -f2- \
              | awk -F'\t' '{
                printf("| `%s` | `%s` | `%s` | `%s` | **%s** |\n",
                  $1,$2,$3,($4==""?"(unknown)":$4),$5)
              }'

              echo
            fi
          } > PR_BODY.md

      - name: Scan new image with Grype + append summary
        if: env.FIX_CVE == 'true' && env.SCAN_WITH_GRYPE == 'true'
        run: |
          set -euo pipefail
          grype "${{ env.NEW_IMAGE }}" -o sarif > grype-results.sarif

          {
            echo ""
            echo "## Grype summary (top findings)"
            echo ""
            echo '```text'
            grype "${{ env.NEW_IMAGE }}" 2>&1 | head -n 120
            echo '```'
          } >> PR_BODY.md

      - name: Upload Grype SARIF results
        if: env.FIX_CVE == 'true' && env.SCAN_WITH_GRYPE == 'true'
        uses: github/codeql-action/upload-sarif@6bb031afdd8eb862ea3fc1848194185e076637e5
        with:
          sarif_file: grype-results.sarif

      - name: Pre-pull docker image for Prisma Cloud scan
        if: env.FIX_CVE == 'true' && env.SCAN_WITH_PRISMA_CLOUD == 'true'
        run: docker pull "${{ env.NEW_IMAGE }}"

      - name: Prisma Cloud image scan
        if: env.FIX_CVE == 'true' && env.SCAN_WITH_PRISMA_CLOUD == 'true'
        id: prismascan
        uses: PaloAltoNetworks/prisma-cloud-scan@124b48d8325c23f58a35da0f1b4d9a6b54301d05 # v1.6.7
        with:
          pcc_console_url: ${{ secrets.PCC_CONSOLE_URL }}
          pcc_user: ${{ secrets.PCC_USER }}
          pcc_pass: ${{ secrets.PCC_PASS }}
          image_name: "${{ env.NEW_IMAGE }}"

      - name: Upload Prisma Cloud SARIF file
        if: env.FIX_CVE == 'true' && env.SCAN_WITH_PRISMA_CLOUD == 'true'
        uses: github/codeql-action/upload-sarif@6bb031afdd8eb862ea3fc1848194185e076637e5
        with:
          sarif_file: ${{ steps.prismascan.outputs.sarif_file }}

      - name: Extract Prisma Cloud Console Link
        if: env.FIX_CVE == 'true' && env.SCAN_WITH_PRISMA_CLOUD == 'true'
        run: |
          set -euo pipefail
          results_file="${{ steps.prismascan.outputs.results_file }}"
          PRISMA_CLOUD_URL="$(cat "$results_file" | jq -r '.consoleURL')"
          echo "PRISMA_CLOUD_URL=$PRISMA_CLOUD_URL" >> "$GITHUB_ENV"

      - name: Append Prisma link to PR body
        if: env.FIX_CVE == 'true' && env.SCAN_WITH_PRISMA_CLOUD == 'true'
        run: |
          set -euo pipefail
          {
            echo ""
            echo "## Prisma Cloud"
            echo ""
            echo "${{ env.PRISMA_CLOUD_URL }}"
          } >> PR_BODY.md

      # Always create a diff to PR when FIX_CVE=true
            # Always create a diff to PR when FIX_CVE=true
      - name: Write CVE resolution results to repo
        if: env.FIX_CVE == 'true'
        run: |
          set -euo pipefail
          mkdir -p demo-results

          # Copy the formatted PR body into the repo so there's always a diff
          cp PR_BODY.md demo-results/last-run.md

          # Force a guaranteed change (even if content repeats)
          echo "" >> demo-results/last-run.md
          echo "run_id=${{ github.run_id }}" >> demo-results/last-run.md

          git add demo-results/last-run.md

      - name: Create Pull Request
        if: env.FIX_CVE == 'true'
        uses: peter-evans/create-pull-request@5e914681df9dc83aa4e4905692ca88beb2f9e91f # v7.0.5
        with:
          token: ${{ steps.octo-sts.outputs.token }}
          commit-message: "Demo: record CVE fix results"
          title: "Demo: CVE fix detected for Python image"
          body-path: PR_BODY.md
          labels: automated pr, cve, patch
          branch: "apply-cve-fix"
          delete-branch: true